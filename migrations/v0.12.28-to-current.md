# Migration: v0.12.28 → current HEAD

Apply BC entries in order first, then read AD entries to learn the new API surface.
See `migrations/README.md` for format details and the full LLM workflow.

---

## Breaking Changes

### BC-01 ModuleLogic type parameter removed

**Type:** Breaking

**Grep:** `: ModuleLogic<`
**File glob:** `**/*.kt`

**Before:**
```kotlin
class MyLogic(dispatch: Dispatch) : ModuleLogic<MyAction>(dispatch) { ... }

val createLogic: (Dispatch) -> ModuleLogic<MyAction> = { MyLogic(it) }
```

**After:**
```kotlin
class MyLogic(dispatch: Dispatch) : ModuleLogic(dispatch) { ... }

val createLogic: (Dispatch) -> ModuleLogic = { MyLogic(it) }
```

**Notes:** Also remove the type argument from any `-> ModuleLogic<X>` return type
annotations. `ModuleLogic` is no longer generic.

---

### BC-02 ModuleLogic lambda factory removed

**Type:** Breaking

**Grep:** `ModuleLogic {`
**File glob:** `**/*.kt`

**Before:**
```kotlin
override val createLogic = { dispatch: Dispatch ->
    ModuleLogic { action ->
        when (action) { ... }
    }
}
```

**After:**
```kotlin
class MyModuleLogic(dispatch: Dispatch) : ModuleLogic(dispatch) {
    // named methods, not invoke()
}

override val createLogic = { dispatch: Dispatch -> MyModuleLogic(dispatch) }
```

**Notes:** The anonymous `ModuleLogic { action -> }` lambda constructor no longer
exists. Callers must provide a concrete subclass. See BC-03 for the related
`invoke()` removal.

---

### BC-03 ModuleLogic.invoke() override removed

**Type:** Breaking

**Grep:** `override suspend fun invoke(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
class MyLogic(dispatch: Dispatch) : ModuleLogic<MyAction>(dispatch) {
    override suspend fun invoke(action: MyAction) {
        when (action) { ... }
    }
}
```

**After:**
```kotlin
class MyLogic(dispatch: Dispatch) : ModuleLogic(dispatch) {
    suspend fun handleSomeAction(param: String) { ... }
}
```

**Notes:** `ModuleLogic` no longer acts as a function receiver. Remove all
`override suspend fun invoke(action: ...)` methods and replace them with named
methods. Update any callers that were dispatching actions expecting the logic
to receive them via `invoke()`.

---

### BC-04 onStoreReset() renamed to beforeReset()

**Type:** Breaking

**Grep:** `onStoreReset()`
**File glob:** `**/*.kt`

**Before:**
```kotlin
override suspend fun onStoreReset() {
    // cleanup called after reinitialization
}
```

**After:**
```kotlin
override suspend fun beforeReset() {
    // cleanup called BEFORE reinitialization — cancel jobs, release resources
}
```

**Notes:** Semantics changed: `beforeReset()` is called *before* modules are
re-initialized, giving logic a chance to cancel coroutines and release resources.
Any code that assumed modules were already reset must be moved earlier or
restructured. See AD-10 for the full lifecycle documentation.

---

### BC-05 @Serializable removed from Screen/Modal objects

**Type:** Breaking

**Grep:** `@Serializable`
**File glob:** `**/screen*/*.kt,**/screens/*.kt,**/navigation/*.kt`

**Before:**
```kotlin
@Serializable
object HomeScreen : Screen {
    override val route = "home"
    ...
}
```

**After:**
```kotlin
object HomeScreen : Screen {
    override val route = "home"
    ...
}
```

**Notes:** Screen and Modal objects are no longer serialized directly. Navigation
state is persisted via route strings, not object references. Remove `@Serializable`
from all `Screen` and `Modal` object declarations.

---

### BC-06 NavTransition.Hold removed

**Type:** Deprecation-removal

**Grep:** `NavTransition.Hold`
**File glob:** `**/*.kt`

**Before:**
```kotlin
override val enterTransition = NavTransition.Hold
override val exitTransition = NavTransition.Hold
```

**After:**
```kotlin
override val enterTransition = NavTransition.None
override val exitTransition = NavTransition.None
```

---

### BC-07 Modal.onDismissTapOutside callback removed

**Type:** Breaking

**Grep:** `onDismissTapOutside`
**File glob:** `**/*.kt`

**Before:**
```kotlin
object MyModal : Modal {
    override val route = "my-modal"
    override val onDismissTapOutside: (() -> Unit)? = { /* custom logic */ }
}
```

**After:**
```kotlin
object MyModal : Modal {
    override val route = "my-modal"
    override val tapOutsideToDismiss: Boolean = true
    override val dismissable: Boolean = true
}
```

**Notes:** The callback is replaced by declarative flags. If you had side-effects
in `onDismissTapOutside`, move them to a `NavigationAction.Back` handler in your
module logic. See AD-04 for the full `tapOutsideToDismiss` / `dismissable` API.

---

### BC-08 NavigationEntry constructor changed

**Type:** Breaking

**Grep:** `NavigationEntry(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
NavigationEntry(
    navigatable = HomeScreen,
    params = mapOf("id" to "123"),
    graphId = "main",
    stackPosition = 0
)
```

**After:**
```kotlin
NavigationEntry(
    path = "main/home",
    params = mapOf("id" to "123"),
    stackPosition = 0
)
```

**Notes:** `path` is the full hierarchical route string — graph IDs joined with `/`,
ending with the screen route (e.g. `"root/main/detail"`). In most cases you will
not construct `NavigationEntry` directly; use the navigation DSL (`navigateTo(Screen)`)
which builds the entry internally.

---

### BC-09 NavigationEntry.navigatable property removed

**Type:** Breaking

**Grep:** `\.navigatable`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val screen = entry.navigatable
val route = entry.navigatable.route
```

**After:**
```kotlin
val navigatable = navigationLogic.resolveNavigatable(entry)
val route = entry.path.substringAfterLast("/")
```

**Notes:** To recover the `Navigatable` object, call
`NavigationLogic.resolveNavigatable(entry)`. Access `NavigationLogic` via
`storeAccessor.selectLogic<NavigationLogic>()`. For the leaf route string alone,
use `entry.path.substringAfterLast("/")`.

---

### BC-10 NavigationAction.BatchUpdate removed

**Type:** Deprecation-removal

**Grep:** `NavigationAction.BatchUpdate`
**File glob:** `**/*.kt`

**Before:**
```kotlin
dispatch(NavigationAction.BatchUpdate(listOf(
    NavigationAction.Navigate(...),
    NavigationAction.Back
)))
```

**After:**
```kotlin
dispatch(NavigationAction.AtomicBatch(listOf(
    NavigationAction.Navigate(...),
    NavigationAction.Back
)))
```

**Notes:** Direct replacement. See AD-05 for `AtomicBatch` documentation.

---

### BC-11 NavigationAction.Back changed from data class to object

**Type:** Breaking

**Grep:** `NavigationAction.Back(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
dispatch(NavigationAction.Back(
    currentEntry = someEntry,
    backStack = someList,
    modalContexts = someMap
))
```

**After:**
```kotlin
dispatch(NavigationAction.Back)
```

**Notes:** `Back` is now a singleton object. The reducer computes the new state
from the current stack. Remove all constructor arguments.

---

### BC-12 NavigationAction.ClearBackstack changed from data class to object

**Type:** Breaking

**Grep:** `NavigationAction.ClearBackstack(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
dispatch(NavigationAction.ClearBackstack(
    newEntry = homeEntry,
    clearModals = true
))
```

**After:**
```kotlin
dispatch(NavigationAction.ClearBackstack)
```

---

### BC-13 NavigationAction.PopUpTo signature changed

**Type:** Breaking

**Grep:** `NavigationAction.PopUpTo(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
dispatch(NavigationAction.PopUpTo(
    newCurrentEntry = targetEntry,
    newBackStack = computedStack,
    newModalContexts = computedModals
))
```

**After:**
```kotlin
dispatch(NavigationAction.PopUpTo(
    route = "target-route",
    inclusive = false
))
```

**Notes:** The reducer now computes the resulting state. Pass the route string of
the target screen and whether to include that screen in the pop. Prefer the
navigation DSL `popUpTo("route", inclusive = false)` inside a `navigate { }` block
over dispatching this action directly.

---

### BC-14 NavigationState guided flow fields removed

**Type:** Breaking

**Grep:** `guidedFlowModifications\|activeGuidedFlowState`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val mods = state.guidedFlowModifications
val flow = state.activeGuidedFlowState
```

**After:**
```kotlin
// No replacement. The guided flow system is removed.
// Use the intercept/guard DSL for conditional navigation (see AD-02 and BC-17).
```

---

### BC-15 NavigationState.visibleLayers element type changed

**Type:** Breaking

**Grep:** `visibleLayers`
**File glob:** `**/*.kt`

**Before:**
```kotlin
// visibleLayers: List<NavigationLayer>
val layer: NavigationLayer = state.visibleLayers.first()
val screen = layer.screen
```

**After:**
```kotlin
// visibleLayers: List<NavigationEntry>
val entry: NavigationEntry = state.visibleLayers.first()
val route = entry.path.substringAfterLast("/")
```

**Notes:** `NavigationLayer` wrapper is removed. `visibleLayers` now directly
contains `NavigationEntry` objects. Update all iteration and destructuring.

---

### BC-16 Computed navigation properties removed from NavigationState

**Type:** Breaking

**Grep:** `orderedBackStack\|canGoBack\|effectiveDepth\|navigationDepth`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val stack = state.orderedBackStack
val canGo = state.canGoBack
val depth = state.effectiveDepth
val navDepth = state.navigationDepth
```

**After:**
```kotlin
val stack = state.backStack
val canGo = state.backStack.size > 1
// derive depth from backStack.size as needed
```

---

### BC-17 All GuidedFlow classes removed

**Type:** Breaking

**Grep:** `GuidedFlow\|GuidedFlowDefinition\|GuidedFlowState\|GuidedFlowStep\|GuidedFlowContext\|FlowModification\|ClearModificationBehavior\|NavigationLayer`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val flow = GuidedFlowDefinition(
    route = "signup-flow",
    steps = listOf(GuidedFlowStep(StepOneScreen), GuidedFlowStep(StepTwoScreen)),
    onComplete = { store.dispatch(MyAction.SignupComplete) }
)
NavigationModule(rootGraph, guidedFlows = listOf(flow))
```

**After:**
```kotlin
// Track wizard progress in your own module state.
// Navigate step-by-step and use intercept guards for access control.
// See AD-01 (createNavigationModule DSL) and AD-02 (intercept guard DSL).
createNavigationModule {
    rootGraph {
        screen(StepOneScreen)
        screen(StepTwoScreen)
        screen(StepThreeScreen)
    }
}
```

**Notes:** Removed: `GuidedFlowDefinition`, `GuidedFlowState`, `GuidedFlowStep`,
`GuidedFlowContext`, `FlowModification`, `ClearModificationBehavior`, `NavigationLayer`.
Replace multi-step wizard flows with sequential navigation using
`store.navigation { navigateTo(StepScreen) }` and track progress in your own module
state. Use intercept guards for authentication-gating (see AD-02).

---

### BC-18 NavigationModule direct constructor replaced by DSL

**Type:** Breaking

**Grep:** `NavigationModule(`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val navModule = NavigationModule(
    rootGraph = myRootGraph,
    deepLinkHandlers = listOf(...)
)
```

**After:**
```kotlin
val navModule = createNavigationModule {
    rootGraph {
        graph("main") {
            screen(HomeScreen)
            screen(DetailScreen)
        }
    }
}
```

**Notes:** See AD-01 for the full `createNavigationModule { }` DSL documentation.

---

### BC-19 NavigationModule parameter originalGuidedFlowDefinitions removed

**Type:** Breaking

**Grep:** `originalGuidedFlowDefinitions`
**File glob:** `**/*.kt`

**Before:**
```kotlin
NavigationModule(
    rootGraph = graph,
    originalGuidedFlowDefinitions = listOf(myFlow)
)
```

**After:**
```kotlin
createNavigationModule {
    rootGraph { ... }
}
```

**Notes:** `originalGuidedFlowDefinitions` is removed with no direct replacement.
See AD-01 for `loadingModal` and `deepLinks { }` which are the new DSL-level
configuration options.

---

### BC-20 Auth guard pattern replaced by intercept DSL

**Type:** Breaking

**Grep:** `NavigationGuard\|navigationGuard\|AuthGuard`
**File glob:** `**/*.kt`

**Before:**
```kotlin
class AuthGuard : NavigationGuard {
    override fun check(target: Screen): Boolean = authState.isLoggedIn
}
NavigationModule(rootGraph, guards = listOf(AuthGuard()))
```

**After:**
```kotlin
createNavigationModule {
    rootGraph {
        intercept(
            guard = { store ->
                val auth = store.selectState<AuthState>()
                if (auth.isLoggedIn) GuardResult.Allow
                else GuardResult.PendAndRedirectTo(LoginScreen.route)
            }
        ) {
            graph("protected") {
                screen(DashboardScreen)
            }
        }
    }
}
```

**Notes:** See AD-02 for the full `intercept { }` DSL and `GuardResult` type
documentation. See AD-08 for `resumePendingNavigation()` which pairs with
`PendAndRedirectTo`.

---

### BC-21 RouteResolution.targetScreen renamed

**Type:** Breaking

**Grep:** `\.targetScreen`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val screen = resolution.targetScreen
```

**After:**
```kotlin
val navigatable = resolution.targetNavigatable
```

---

### BC-22 ScreenResolution.screen renamed

**Type:** Breaking

**Grep:** `screenResolution\.screen\b\|resolution\.screen\b`
**File glob:** `**/*.kt`

**Before:**
```kotlin
val screen = screenResolution.screen
```

**After:**
```kotlin
val navigatable = screenResolution.navigatable
```

---

### BC-23 NavigationLogic.navigate() now returns NavigationOutcome

**Type:** Behavioural

**Grep:** `navLogic\.navigate {`
**File glob:** `**/*.kt`

**Before:**
```kotlin
// navigate() returned Unit
navLogic.navigate {
    navigateTo(HomeScreen)
}
```

**After:**
```kotlin
// navigate() now returns NavigationOutcome — inspect if needed
val outcome = navLogic.navigate {
    navigateTo(HomeScreen)
}
// outcome can be: Success, Dropped, Rejected, Redirected
```

**Notes:** The return value can be ignored for fire-and-forget navigation. Only
update callers that need to react to guard outcomes (e.g., show an error on
`Rejected`). The `StoreAccessor.navigation { }` convenience extension continues
to work unchanged. See AD-03 for the full `NavigationOutcome` type documentation.

---

## Additions

### AD-01 createNavigationModule { } DSL

**Type:** Addition

**Grep:** `createNavigationModule`
**File glob:** `**/*.kt`

**Example:**
```kotlin
val navModule = createNavigationModule {
    // Required: define the root graph
    rootGraph {
        // Top-level screens accessible from anywhere
        screen(SplashScreen)

        // Named sub-graphs group related screens
        graph("main") {
            screen(HomeScreen)
            screen(DetailScreen)
            screen(ProfileScreen)
        }

        graph("auth") {
            screen(LoginScreen)
            screen(SignupScreen)
        }
    }

    // Optional: modal shown during async navigation / deep link resolution
    loadingModal = AppLoadingModal

    // Optional: deep link aliases map URLs to screen routes
    deepLinks {
        alias("myapp://home", HomeScreen.route)
        alias("myapp://product/{id}", DetailScreen.route)
    }
}
```

**Notes:** Replaces the direct `NavigationModule(...)` constructor (see BC-18).
All graph structure, loading modals, and deep link configuration live inside
this DSL block. The returned module is used in `createStore { module(navModule) }`.

---

### AD-02 intercept { } guard DSL + GuardResult

**Type:** Addition

**Grep:** `intercept(`
**File glob:** `**/*.kt`

**Example:**
```kotlin
createNavigationModule {
    rootGraph {
        // Wrap any graph block with intercept() to add an access guard
        intercept(
            guard = { store ->
                val auth = store.selectState<AuthState>()
                when {
                    auth.isLoggedIn -> GuardResult.Allow
                    auth.isPending -> GuardResult.Reject
                    else -> GuardResult.PendAndRedirectTo(LoginScreen.route)
                }
            }
        ) {
            graph("protected") {
                screen(DashboardScreen)
                screen(SettingsScreen)
            }
        }

        // Unguarded screens sit outside the intercept block
        screen(LoginScreen)
    }
}
```

**GuardResult options:**
```kotlin
GuardResult.Allow                          // navigation proceeds
GuardResult.Reject                         // navigation blocked, no redirect
GuardResult.RedirectTo(route: String)      // navigate elsewhere instead
GuardResult.PendAndRedirectTo(route: String) // store intent, redirect for now;
                                             // resume later with resumePendingNavigation()
```

**Notes:** Guards receive a `StoreAccessor` so they can read any module state.
`PendAndRedirectTo` is the login-wall pattern — redirect the user to login, then
call `store.resumePendingNavigation()` after authentication succeeds to replay
the original navigation intent (see AD-08).

---

### AD-03 NavigationOutcome sealed class

**Type:** Addition

**Grep:** `NavigationOutcome`
**File glob:** `**/*.kt`

**Example:**
```kotlin
val outcome: NavigationOutcome = navLogic.navigate {
    navigateTo(DashboardScreen)
}

when (outcome) {
    is NavigationOutcome.Success ->
        // Navigation applied; outcome.entry is the new current entry
        log("navigated to ${outcome.entry.path}")

    is NavigationOutcome.Dropped ->
        // No-op: target was already the current screen
        Unit

    is NavigationOutcome.Rejected ->
        // Guard blocked the navigation; no redirect
        showError("Access denied")

    is NavigationOutcome.Redirected ->
        // Guard redirected elsewhere; outcome.to is the redirect target route
        log("redirected to ${outcome.to}")
}
```

**Notes:** The return value of `NavigationLogic.navigate()` (see BC-23). The
`StoreAccessor.navigation { }` extension discards the outcome for fire-and-forget
use cases.

---

### AD-04 Modal.tapOutsideToDismiss and Modal.dismissable properties

**Type:** Replaces-deprecated

**Grep:** `tapOutsideToDismiss\|dismissable`
**File glob:** `**/*.kt`

**Replaces:** `Modal.onDismissTapOutside: (() -> Unit)?` callback (removed, see BC-07)

**Example:**
```kotlin
object ConfirmationModal : Modal {
    override val route = "confirmation"

    // Allow the modal to be dismissed at all (back gesture, system back)
    override val dismissable: Boolean = true

    // Allow tapping the scrim behind the modal to dismiss it
    override val tapOutsideToDismiss: Boolean = true

    @Composable
    override fun Content(params: Map<String, Any>) { ... }
}

object BlockingModal : Modal {
    override val route = "blocking"
    override val dismissable: Boolean = false        // cannot be dismissed by user
    override val tapOutsideToDismiss: Boolean = false
    ...
}
```

**Notes:** Both properties default to `true`. `dismissable = false` prevents the
system back gesture from closing the modal in addition to disabling scrim taps.

---

### AD-05 NavigationAction.AtomicBatch

**Type:** Replaces-deprecated

**Grep:** `NavigationAction.AtomicBatch`
**File glob:** `**/*.kt`

**Replaces:** `NavigationAction.BatchUpdate` (removed, see BC-10)

**Example:**
```kotlin
// Apply multiple navigation actions as a single atomic state update
dispatch(NavigationAction.AtomicBatch(listOf(
    NavigationAction.Navigate(entry),
    NavigationAction.Back
)))
```

**Notes:** Identical semantics to the removed `BatchUpdate`. The rename aligns
with the broader "atomic" language used in the navigation system.

---

### AD-06 Internal NavigationAction additions (awareness)

**Type:** Addition

**Grep:** `SetPendingNavigation\|ClearPendingNavigation\|BootstrapComplete\|RemoveLoadingModals\|SetCurrentTitle`
**File glob:** `**/*.kt`

**Example:**
```kotlin
// These actions are dispatched internally by NavigationLogic.
// Do not dispatch them directly from application code.
// They appear in DevTools middleware traces and middleware implementations.
NavigationAction.SetPendingNavigation(intent)
NavigationAction.ClearPendingNavigation
NavigationAction.BootstrapComplete
NavigationAction.RemoveLoadingModals
NavigationAction.SetCurrentTitle(title)
```

**Notes:** These actions exist for internal lifecycle management. You may observe
them in DevTools or middleware but should not dispatch them from application code.
If you write custom middleware that inspects navigation actions, handle them
as no-ops.

---

### AD-07 store.navigateDeepLink(url)

**Type:** Addition

**Grep:** `navigateDeepLink`
**File glob:** `**/*.kt`

**Example:**
```kotlin
// Android: call from Activity.onNewIntent or onCreate
override fun onNewIntent(intent: Intent) {
    super.onNewIntent(intent)
    intent.data?.toString()?.let { url ->
        lifecycleScope.launch {
            storeAccessor.navigateDeepLink(url)
        }
    }
}

// URL format matches aliases defined in the navigation DSL (see AD-01)
// e.g. "myapp://product/42" resolves to DetailScreen with params = {"id": "42"}
```

**Notes:** Guards are evaluated during deep link resolution. If a guard returns
`PendAndRedirectTo`, the deep link is stored as a pending navigation intent and
can be resumed after satisfying the guard (see AD-08).

---

### AD-08 store.resumePendingNavigation()

**Type:** Addition

**Grep:** `resumePendingNavigation`
**File glob:** `**/*.kt`

**Example:**
```kotlin
// After the user completes login, resume the navigation they originally requested
class AuthLogic(dispatch: Dispatch) : ModuleLogic(dispatch) {
    suspend fun onLoginSuccess() {
        dispatch(AuthAction.SetLoggedIn)
        // Resume the navigation intent stored by a PendAndRedirectTo guard
        storeAccessor.resumePendingNavigation()
    }
}
```

**Notes:** Pairs with `GuardResult.PendAndRedirectTo` in the intercept DSL (see AD-02).
If there is no pending navigation intent, this is a no-op. The pending intent is
cleared after resumption regardless of outcome.

---

### AD-09 store.reset() and store.resetAsync()

**Type:** Addition

**Grep:** `\.reset()\|\.resetAsync()`
**File glob:** `**/*.kt`

**Example:**
```kotlin
// Suspending reset — use from a coroutine
class AuthLogic(dispatch: Dispatch) : ModuleLogic(dispatch) {
    suspend fun onLogout() {
        storeAccessor.reset()
        // All modules are back to initialState; fresh logic instances created
    }
}

// Fire-and-forget reset — use from non-suspending context
fun onLogoutButtonClicked() {
    store.resetAsync()
}
```

**Notes:** Before each module is re-initialized, `beforeReset()` is called on its
current logic instance (see AD-10 / BC-04). Use `reset()` for logout flows and
any scenario requiring a full application state wipe.

---

### AD-10 ModuleLogic.beforeReset() lifecycle hook

**Type:** Replaces-deprecated

**Grep:** `beforeReset()`
**File glob:** `**/*.kt`

**Replaces:** `ModuleLogic.onStoreReset()` (renamed, see BC-04)

**Example:**
```kotlin
class MyLogic(dispatch: Dispatch) : ModuleLogic(dispatch) {
    private val job = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.Default + job)

    init {
        scope.launch { pollForUpdates() }
    }

    override suspend fun beforeReset() {
        // Cancel all coroutines before the store is re-initialized.
        // Called before initialState is restored and a new logic instance is created.
        job.cancel()
    }

    private suspend fun pollForUpdates() { ... }
}
```

**Notes:** `beforeReset()` is called before module state is restored to
`initialState` and before a new logic instance is constructed. This is the correct
place to cancel coroutines, close connections, and release resources. After
`beforeReset()` returns, the logic instance is discarded.

---

### AD-11 loadingModal support in NavigationModule

**Type:** Addition

**Grep:** `loadingModal`
**File glob:** `**/*.kt`

**Example:**
```kotlin
// Define a loading modal
object AppLoadingModal : Modal {
    override val route = "loading"
    override val dismissable: Boolean = false
    override val tapOutsideToDismiss: Boolean = false

    @Composable
    override fun Content(params: Map<String, Any>) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
    }
}

// Register it in the navigation module
val navModule = createNavigationModule {
    rootGraph { ... }
    loadingModal = AppLoadingModal
}
```

**Notes:** The loading modal is shown automatically during async navigation
operations (e.g. deep link resolution while guards are evaluated) and removed
when navigation settles. It is dispatched via `NavigationAction.RemoveLoadingModals`
internally (see AD-06). Only one loading modal can be registered per module.

---

### AD-12 Built-in deep link alias system

**Type:** Addition

**Grep:** `deepLinks {`
**File glob:** `**/*.kt`

**Example:**
```kotlin
val navModule = createNavigationModule {
    rootGraph {
        screen(HomeScreen)
        screen(DetailScreen)
        screen(ProfileScreen)
    }

    deepLinks {
        // Static alias: exact URL maps to a screen route
        alias("myapp://home", HomeScreen.route)

        // Parameterised alias: {param} segments are extracted and passed as
        // navigation params to the target screen
        alias("myapp://product/{id}", DetailScreen.route)
        alias("myapp://user/{userId}/post/{postId}", ProfileScreen.route)
    }
}

// Entry point — call this whenever the app receives a deep link URL
storeAccessor.navigateDeepLink("myapp://product/42")
// DetailScreen receives params = mapOf("id" to "42")
```

**Notes:** If the target project contains any of the following, this system is
likely a direct replacement:
- Manual URI parsing (`Uri.parse`, `intent.data`, URL splitting/regex)
- Hand-written URL-to-route mapping tables or `when`/`if` chains that inspect
  incoming URLs and call navigation functions
- Custom `DeepLinkHandler`, `DeepLinkRouter`, or similarly named classes
- `onNewIntent` / `handleIntent` methods that extract path segments and dispatch
  navigation actions directly

The built-in system handles URL parsing, parameter extraction, guard evaluation,
and the loading modal automatically. Guards defined with `intercept { }` (see AD-02)
apply to deep link navigation the same way they apply to in-app navigation. If a
guard returns `PendAndRedirectTo`, the deep link intent is stored and can be resumed
with `resumePendingNavigation()` after the precondition is satisfied (see AD-08).

---
